# IBM Quantum Awards: Open Science Prize 2021 - QTime solution

In this repository we present our solution for the IBM Quantum Awards: Open Science Prize 2021.

```
.
├── initial_versions/
├── final_versions/
│   ├── figs/ 
│   ├── results/ 
│   ├── troter_utils.py
│   ├── classical_opt_larger_times.ipynb
│   ├── classical_opt_smaller_times_jobs_sent.ipynb
│   ├── classical_opt_negative_times_jobs_sent.ipynb
│   ├── final_results_analysis.ipynb
├── initial_versions/
└── README.md
```

In the folder `initial_versions` you can find several notebook (.ipynb) and script (.py) Python files. These represent our first ideas and tests in the direction of the solution. Some of these attempts are referenced in the main .pdf file in which our solution is detailed, which is why we opted to include them. That said, these files were not thoroughly documented, and the code therein should not be used for final evaluation of the solution.

In the folder `final_versions` you find the final versions of the code produced for our solution. In what follows, we detail each file in this folder.

- `troter_utils.py`: this is the main module associated with our solution. In this file you can find the imports as well as all the functions written and used in the solution. All functions defined in this module are thoroughly commented, motivated in the solution description, and written in a way that their inner workings are clear. This module is imported and used in all the notebooks, in order to make them concise and straightforward. 

- `classical_opt_larger_times.ipynb`: in this notebook, the classical optimization of the variational circuit is performed, and the results are saves as parquet files (for the better parsing of data structures such as list, which are in some columns of the dataframe). Notice: `pyarrow` (or `fastparquet`) is necessary for working with parquet files, so make sure to install this module for the code to be fully reproducible. In this first notebook, we use relatively large minimum times for each trotter step in the constrained optimization, as a first experiment. In the markdown cells of this notebook, the general rational and structure of the experiments (which are replicated in the following notebooks) are thoroughly explained, so they are worth reading.

- `classical_opt_smaller_times_jobs_sent.ipynb`: this notebook is structurally similar to the previous one: the classical optimization is performed, and the results are saved. Beyond that, we also added an extra section `Hardware execution`, in which we submit the jobs for hardware execution. To better retrieve the results, we save a pickle file with a dictionary in the respective format: `{"experiment_identification": [list of respective jobs' IDs]}` for each experiment setting. This is used to retrieve the jobs ans assist the final results' analysis, which is done in a dedicated notebook, described below.

_ `classical_opt_negative_times_jobs_sent.ipynb`: this is the same as the previous notebook, but here we allow for negative times (please see the solution description for details).

- `final_results_analysis.ipynb`: in this notebook, the completed hardware execution jobs are retrieved, and the results are analyzed and concatenated with the noisy simulation results, producing the final results tables, as well as a stacked table with the results of all experiments, sorted by the best hardware mean fidelity.

Within the `final_versions` folder you can also find two other subfolders:

- `figs/`: folder with plots of the target state fidelity as a function of time, for the full Hamiltonian evolution (time from 0 to pi). Some of these plots are referenced in the solution description.

- `results/`: folder with aforementioned parquet and pickle result files. The files in this folder are the ones generated by the code in the respective notebooks, in the indicated dates. The cells' outputs (as well as information from nbxtensions' `Èxecute Time`) of all aforementioned notebooks were kept, so that the generation of such results may be identified. 

- `results_other_members`: some of the results in the main results table (available in the .pdf with the solution description) were obtained via jobs which were sent for execution by other members of the team, and produced by slightly different codes, yielding slightly differently-structured results files. For this reason, these files were kept in this folder, separated from the other ones in the `results/` folder, whose production is registered in the aformentioned notebook outputs.